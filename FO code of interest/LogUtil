package sg.ica.eac.common.util;

import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.ThreadContext;

public abstract class LogUtil {
	private static final String TRANSID = "transId";
	private static final String USERID = "userId";
	private static final String RESRCID = "resrcId";
	private static final String FRONTENDID = "frontEndId";
	
	private static final String LOG_AUDIT = "LOG_AUDIT";
	private LogUtil() {}
	public static void reset() {
		ThreadContext.clearAll();
	}

	public static void init(String userId, String resourceId) {
		init(userId, resourceId, ThreadContext.get(TRANSID));
	}

	public static void init(String userId, String resourceId, String transactionId) {
		// Thread Context Map is the equivalent of the MDC and the Thread Context Stack is the equivalent of the NDC.
		// If more values are needed to be logged, just add more keys and call the key from log4j2.xml
		ThreadContext.put(USERID, userId);
		ThreadContext.put(RESRCID, resourceId);
		ThreadContext.put(TRANSID, StringUtils.isBlank(transactionId) ? TransactionIdGenerator.generateTransactionId() : transactionId);
	}

	public static String getTransactionId() {
		return ThreadContext.get(TRANSID);
	}

	public static String getUserId() {
		return ThreadContext.get(USERID);
	}

	public static String getResourceId() {
		return ThreadContext.get(RESRCID);
	}
	
	public static String getFrontEndId() {
		return ThreadContext.get(FRONTENDID);
	}
	
	public static void setFrontEndId(String frontEndId) {
		ThreadContext.put(FRONTENDID, frontEndId);
	}

	public static void logPerf(long duration) {
		LogManager.getLogger("LOG_PERF").info(duration);
	}

	public static void logAlert(Throwable t, String format, Object... params) {
		String message = (format != null) ? String.format(format, params) : "";
		LogManager.getLogger("LOG_ALERT").info(message, t);
	}

	public static void logUsage(Map<String, String> keyValues) {
		StringBuilder sb = null;
		if (keyValues != null) {
			sb = new StringBuilder();
			boolean start = true;
			for (Entry<String, String> keyValue : keyValues.entrySet()) {
				if (keyValue != null) {
					if (start) {
						start = false;
					} else {
						sb.append(",");
					}
					sb.append(keyValue.getKey());
					sb.append("=");
					sb.append(keyValue.getValue());
				}
			}
		}
		logUsage(sb != null ? sb.toString() : "");
	}

	public static void logUsage(String format) {
	    String message = String.format(format);
	    LogManager.getLogger("LOG_USAGE").info(message);
	}

	public static void logDebug(String format, Object... params) {
		String message = (format != null) ? String.format(format, params) : "";
		LogManager.getLogger(LOG_AUDIT).debug(message);
	}

	public static void logInfo(String format, Object... params) {
	    String message = (format != null) ? String.format(format, params) : "";
	    LogManager.getLogger(LOG_AUDIT).info(message);
	}

	public static void logError(Throwable t, String format, Object... params) {
	    String message = (format != null) ? String.format(format, params) : "";
	    LogManager.getLogger(LOG_AUDIT).error(message, t);
	}

	public static boolean logResponse(List<String> urlsToExclude, String path) {
		if (CollectionUtils.isNotEmpty(urlsToExclude)) {
			return !hasMatchingSubstring(path, urlsToExclude); // returns true if path string is not excluded
		}
		return true;
	}
	private static boolean hasMatchingSubstring(String str, List<String> substrings) {
		return substrings.stream().anyMatch(str::contains);
	}

}
